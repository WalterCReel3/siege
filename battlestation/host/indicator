# !/usr/bin/env python
#
# Receives score information from the Siege server and formats it for display
# on the light towers, then sends it to the Arduino program over a serial
# connection.
#
# Needs pyserial (pip install pyserial or apt-get install python-serial).

import random
import sys
import time
import serial


def shake_hands(serial_file):
    for attempt in range(10):
        print('shaking hands with indicator device...')
        if execute(serial_file, 'p'):
            print('indicator connected')
            return True
    print('could not connect to indicator device')
    return False


# Sends the command to the Arduino and returns True if the command executed
# successfully, False if there was an error.
def execute(serial_file, command):
    # Consume the text prompt or any left-overs from previous commands
    while serial_file.inWaiting() > 0:
        serial_file.read()

    # Communication with the Arduino uses very simple flow control that remains
    # human friendly for manual debugging.  The host sends a command terminated
    # by a newline, the command executes, and the Arduino's response is one
    # or more lines that always ends in a full line of text of "ok" or "err".
    serial_file.write(command + '\n')
    serial_file.flush()
    while True:
        line = serial_file.readline()
        if not line:
            print('timeout waiting for ok ("%s")' % command)
            return False

        line = line.strip()
        if line == 'ok':
            return True
        elif line == 'err':
            return False


def normalize(scores, max):
    summation = sum(scores)
    new_scores = []
    for score in scores:
        val = (float(score) / summation) * max
        val = int(round(val))
        new_scores.append(val)
    return new_scores


# TODO get these from the server in whatever format
def get_territory_info():
    return {
        0: {'points': [random.uniform(0, 100), random.uniform(0, 100), random.uniform(0, 100)]},
        1: {'points': [1000, 2000, 3000]},
        2: {'points': [1000, 2000, 3000]},
        3: {'points': [1000, 2000, 3000]},
    }


if __name__ == "__main__":
    if len(sys.argv) < 2:
        sys.stderr.write('usage: %s /dev/ttyUSBn speed\n' % sys.argv[0])
        sys.exit(1)

    serial_dev = sys.argv[1]
    speed = int(sys.argv[2])
    with serial.Serial(serial_dev, speed, timeout=1) as serial_file:
        shake_hands(serial_file)

        # TODO invert this control
        previous_raw_points = {}
        while True:
            for territory, info in get_territory_info().iteritems():
                raw_points = info['points']

                # If the points changed since last time, flash the strip
                flash = previous_raw_points.get(territory, raw_points) != raw_points

                # Update the right proportion of LEDs for each team's points
                scaled_points = normalize(raw_points, 60)
                execute(serial_file, 's %d 0 %d 1 %d 2 %d' %
                        (territory, scaled_points[0], scaled_points[1], scaled_points[2]))

                # Flash if it was different
                if flash:
                    execute(serial_file, 'f %d' % territory)

                previous_raw_points[territory] = raw_points

                # TODO remove
                time.sleep(random.uniform(1, 7))
