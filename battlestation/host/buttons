#!/usr/bin/env python
#
# Handles button presses on the Siege battlestation and sends events to the
# Seige server.

import sys
import logging
import contextlib
import termios
import time

from socketIO_client import SocketIO, BaseNamespace

DEVICES = {
    0: 'znemxs63dyddy',
    1: 'kjdobbempami4',
    2: 'hguxnrsq4vdq4'
}

# Maps keys to teams.  These are the default chars we get from the Minpac for pin 1-n
# (ignoring groups)
KEYMAP = {
    '\t': 0,
    '\x1b': 0,
    'p': 0,

    '\x10': 1,
    'j': 1,
    'l': 1,

    'i': 2,
    'k': 2,
    'q': 2,
}


# Handles events on the root namespace
class RootNamespace(BaseNamespace):
    def __init__(self, transport, path):
        BaseNamespace.__init__(self, transport, path)
        self._buttons = None

    @property
    def buttons(self):
        return self._buttons

    @buttons.setter
    def buttons(self, value):
        self._buttons = value

    def on_disconnect(self):
        self._buttons.stop = True


class GameNamespace(BaseNamespace):
    def __init__(self, transport, path):
        BaseNamespace.__init__(self, transport, path)
        self._logger = logging.getLogger(type(self).__name__)


class Buttons(object):
    def __init__(self):
        self._logger = logging.getLogger(type(self).__name__)
        self._stop = False

    @property
    def stop(self):
        return self._stop

    @stop.setter
    def stop(self, value):
        self._stop = value

    @contextlib.contextmanager
    def _non_blocking_term(self, f, echo=True):
        fd = f.fileno()
        old_attr = None
        try:
            old_attr = termios.tcgetattr(fd)
            new_attr = termios.tcgetattr(fd)
            new_attr[3] = new_attr[3] & ~termios.ICANON
            if not echo:
                new_attr[3] = new_attr[3] & ~termios.ECHO
            new_attr[6][termios.VMIN] = 0
            new_attr[6][termios.VTIME] = 0
            termios.tcsetattr(fd, termios.TCSANOW, new_attr)
            yield
        except termios.error as err:
            self._logger.warn('error setting nonblocking terminal: %s', str(err))
            yield
        finally:
            if old_attr:
                termios.tcsetattr(fd, termios.TCSADRAIN, old_attr)

    def run(self):
        with self._non_blocking_term(sys.stdin, echo=False):
            with SocketIO('clicksiege.com', port=80) as socketIO:
                root = socketIO.define(RootNamespace)
                root.buttons = self
                game = socketIO.define(GameNamespace, '/game')
                while not self.stop:
                    char = sys.stdin.read(1)
                    if char:
                        team = KEYMAP.get(char, None)
                        if team is not None:
                            self._logger.debug('team %d on territory %d', team, 0)
                            game.emit('click-event', dict(device_id=DEVICES[team], territory=0))
                        else:
                            self._logger.error('key "%s" (dec %d) is not mapped to a team', char, ord(char))

                    # Small sleep so we don't burn down the house
                    time.sleep(0.0001)


# Does the thing
def main():
    logging.basicConfig(level=logging.DEBUG)
    logger = logging.getLogger()

    buttons = Buttons()
    buttons.run()


if __name__ == "__main__":
    main()
